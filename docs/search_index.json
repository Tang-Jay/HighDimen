[["index.html", "高维数据 第 1 章 前言 1.1 致谢 1.2 求解\\(\\lambda\\)数值解", " 高维数据 唐洁，邹云龙 2022-09-30 第 1 章 前言 高维研究的R笔记。 Codes Bookdown Online 1.1 致谢 感谢谢益辉开发的bookdown和模板。 1.2 求解\\(\\lambda\\)数值解 #=============================================== # Chen et al 2008 #=============================================== lambdaChen&lt;-function(u){# u为p*n,p是X的维数，n是数据的个数 p=dim(u)[2] M=rep(0,p) k=0 gama=1 tol=1e-11 dif=1 R1=rep(0,p) R2=R1%*%t(R1) while(dif&gt;tol &amp;&amp; k&lt;=300){ # 计算R1、R2 aa=1+t(M)%*%t(u) for(i in 1:p){ R1[i]=sum(t(u[,i])/aa) for(j in 1:p){ R2[i,j]=-sum(u[,i]*u[,j]/aa^2) } } delta=-solve(R2)%*%R1 dif=c(sqrt(t(delta)%*%delta)) sigma=gama*delta while(min(1+t(M+sigma)%*%t(u))&lt;=0){ gama=gama/2 sigma=gama*delta } M=M+sigma gama=1/sqrt(k+1) k=k+1 } return(M) } # 检验 # lam = lambdaChen(z) # aa=1+t(lam)%*%t(z) # glam=rowSums(t(z)/matrix(aa,p,n,byrow = TRUE)) # print(max(abs(glam))) "],["section.html", "第 2 章 2020-09-27 2.1 模拟结果 2.2 运行代码", " 第 2 章 2020-09-27 复现2009ChenSX，P716-718分位数图。 2009ChenSX.pdf 代码下载 2.1 模拟结果 \\(\\{X_i\\}_{i=1}^n \\in \\mathbb{R}^p\\) 是独立同分布随机变量，来自下面的移动平均模型： \\[X_{ij}=Z_{ij}+\\rho Z_{ij+1} \\quad (i=1,\\cdots,n,\\ j=1,\\cdots,p)\\] 此处，对于任意\\(i\\)，\\(\\{Z_{ij}\\}_{j=1}^{p+1}\\)是独立随机变量，并且均值为0，方差相同。我们取标准正态误差。 \\(\\rho=0.5\\) \\(n = 200,400,800\\) \\(p=c_1n^{0.4}\\)，\\(c_1 = 3,4,5\\) \\(p=c_2n^{0.24}\\)，\\(c_2 = 4,6,8\\) 2.2 运行代码 2.2.1 覆盖率 #=============================================== # High dimensional Data #=============================================== # rm(list = ls()) # source(&#39;GlambdaChen.R&#39;) #==================修改参数====================# nsim = 100 n = 800 size = c(42,55,72) rho = 0.5 a = 0.95 #==================开始模拟====================# cat(&#39;模型进行&#39;,nsim,&#39;次&#39;,&#39;\\n&#39;) cat(&#39;n &#39;,&#39;p &#39;,&#39; EL &#39;,&#39;MEL1 &#39;,&#39;MEL2 &#39;,&#39;\\n&#39;) for (p in size){ mu = rep(0,p) Sigma = diag(p) for(i in 1:p){ for(j in 1:p){ if(abs(i-j)==1){Sigma[i,j] = rho} } } f1 = 0 f2 = 0 f3 = 0 for(i in 1:nsim){ # 估计方程赋值 Z = matrix(rnorm(n*(p+1),0,1), p+1, n) Z1 = Z[-(p+1),] Z2 = Z[-1,] X = Z1 + rho*Z2 z = t(X) # 计算EL值 lam = lambdaChen(z) el = 2*sum( log(1+t(lam)%*%t(z)) ) mel = (el-p)/sqrt(2*p) if( el &lt;= qchisq(a,p) ) f1=f1+1 if( mel &lt;= qnorm(a,0,1)) f2=f2+1 if( abs(mel) &lt;= qnorm(a+(1-a)/2,0,1)) f3=f3+1 # aa=1+t(lam)%*%t(z) # glam=rowSums(t(z)/matrix(aa,p,n,byrow = TRUE)) # print(max(abs(glam))) # cat(el,mel,&#39;\\n&#39;) } # cat(&#39;n =&#39;,n,&#39;p =&#39;,p,&#39;EL =&#39;,f1/nsim,&#39;MEL1 =&#39;,f2/nsim,&#39;MEL2 =&#39;,f3/nsim,&#39;\\n&#39;) cat(n,p,f1/nsim,f2/nsim,f3/nsim,&#39;\\n&#39;) } 2.2.2 绘制分位数图 #=============================================== # figure Q-Q #=============================================== # source(&#39;GlambdaChen.R&#39;) #===================修改参数==================== nsim = 100 # 模拟次数 n = 800 # 样本个数 size = c(42,55,72) # p m = 100 # 分位数个数 as = (1:m-0.5)/m #===================收集数据==================== j = 0 C = matrix(NA,nsim,length(size)) colnames(C)=c(&#39;c1&#39;,&#39;c2&#39;,&#39;c3&#39;) for(p in size){ j = j + 1 f = 0 for(i in 1:nsim){ # 估计方程赋值 Z = matrix(rnorm(n*(p+1),0,1), p+1, n) Z1 = Z[-(p+1),] Z2 = Z[-1,] X = Z1 + 0.5*Z2 z = t(X) # 计算EL值 lam = lambdaChen(z) el = 2*sum( log(1+t(lam)%*%t(z)) ) mel = (el - p) / sqrt(2*p) if( abs(mel) &lt;= qnorm(0.975)) f = f + 1 C[i,j] = mel } cat(&#39;n =&#39;,n,&#39;p =&#39;,p,&#39;覆盖率&#39;,f/nsim,&#39;\\n&#39;) } write.csv(C, file = paste0(&#39;EL&#39;,n,p,&#39;.csv&#39;), row.names = FALSE) # 保存数据 qas &lt;- qnorm(as) # 正态分布的分位数点 c1 = sort(C[,1])[ceiling(as*nsim)] # mel的分位数点 c2 = sort(C[,2])[ceiling(as*nsim)] c3 = sort(C[,3])[ceiling(as*nsim)] #===================绘制QQ图==================== x = seq(-3,3,0.01) plot(x,x, xlim = c(-3,3), ylim = c(-3,3), xaxs = &#39;i&#39;, yaxs = &#39;i&#39;, yaxt = &#39;n&#39;, ann = F, type = &#39;l&#39;) axis(2, las = 1) title(main = paste0(&#39;Normal n = &#39;,n), xlab= &#39;Normal quantile&#39;, ylab = &#39;EL quantile&#39;, line = 2) lines(qas,c1,type=&#39;l&#39;,lty=1,lwd=1.5,col=&#39;blue1&#39;) lines(qas,c2,type=&#39;l&#39;,lty=3,lwd=1.5,col=&#39;aquamarine4&#39;) lines(qas,c3,type=&#39;l&#39;,lty=5,lwd=1.5,col=&#39;brown2&#39;) "],["section-1.html", "第 3 章 2022-09-30 3.1 模拟结果 3.2 运行代码", " 第 3 章 2022-09-30 根据2007ShiJ，做一个高维线性模型的模拟，其中\\(X_{ij}\\)的取值参考2020ChangJY。 2007ShiJ.pdf 2020ChangJY.pdf 代码下载 3.1 模拟结果 \\[Y = X^\\mathsf{T}\\beta + \\epsilon\\] \\(n\\)表示样本个数 \\(n = 200,400,800\\) \\(p\\)表示样本维数 \\(p=cn^{index}\\) \\(index=0.16,0.24,0.4\\) \\(c = 3,4,5\\) \\(X_i \\sim N(0,\\Sigma_{p}), \\Sigma_{p}=(\\sigma_{ij})_{p \\times p}\\) \\(\\sigma_{ij}=I(i=j)+0.5I(i \\neq j)\\) \\(I(x \\in \\omega)= \\left\\{ \\begin{aligned} \\nonumber 1,&amp; x \\in \\omega,\\\\ 0,&amp;x \\notin \\omega.\\\\ \\end{aligned} \\right.\\) 3.1.1 调整EL与未调整EL对比 3.1.2 调整EL在高维中表现 3.1.3 未调整EL在高维中表现 3.2 运行代码 #=============================================== # High-dim linear model #=============================================== rm(list = ls()) library(&#39;MASS&#39;) source(&#39;GlambdaChen.R&#39;) # ==================修改参数==================== nsim = 500 n = 400 index = 0.2 c = c(3,4,5) ps = round(c*n^index) # ==================开始模拟==================== EL = matrix(NA,nsim,length(ps)) colnames(EL)=c(paste0(&#39;p=&#39;,ps[1]),ps[2],ps[3]) MEL = matrix(NA,nsim,length(ps)) colnames(MEL)=c(ps[1],ps[2],ps[3]) cat(&#39;nsim =&#39;,nsim,&#39;\\n&#39;) j = 0 for(p in ps){ j = j + 1 f1 = 0 mu = rep(0,p) Sigma = diag(p) for(k in 1:p){ for(l in 1:p){ if(k != l){Sigma[k,l] = 0.5} } } for(i in 1:nsim){ # 估计方程赋值 X = mvrnorm(n,mu,Sigma) e = rnorm(n) # Y = X%*%theta + e z = X*e # 计算MEL值 lam = lambdaChen(z) el = 2*sum(log(1+t(lam)%*%t(z))) mel = (el-p)/sqrt(2*p) if(abs(mel)&lt;=qnorm(0.975)) f1 = f1 + 1 # 检验lam # aa=1+t(lam)%*%t(z) # glam=rowSums(t(z)/matrix(aa,p,n,byrow = TRUE)) # cat(m,max(abs(glam)),&#39;\\n&#39;) EL[i,j] = el MEL[i,j] = mel } cat(&#39;n =&#39;,n,&#39;p =&#39;,p,&#39;覆盖率&#39;,f1/nsim,&#39;\\n&#39;) } write.csv( EL, file = paste0(&#39;EL&#39; ,n,index,&#39;.csv&#39;), row.names = FALSE) # 保存数据 write.csv(MEL, file = paste0(&#39;MEL&#39;,n,index,&#39;.csv&#39;), row.names = FALSE) # 保存数据 # ===================绘制QQ图==================== m = 50 # 分位数个数 as = (1:m-0.5)/m # 名义水平 par(mfrow = c(1, 2)) # 绘制正态QQ图 qas &lt;- qnorm(as) # 正态分布的分位数点 c1 = sort(MEL[,1])[ceiling(as*nsim)] # mel的分位数点 c2 = sort(MEL[,2])[ceiling(as*nsim)] c3 = sort(MEL[,3])[ceiling(as*nsim)] plot(qas,qas,xaxs = &#39;i&#39;, yaxs = &#39;i&#39;, yaxt = &#39;n&#39;, ann = F, type = &#39;l&#39;) axis(2, las = 1) title(main = paste0(&#39;Norm n = &#39;,n,&#39; index = &#39;,index), xlab = &#39;Normal quantile&#39;, ylab = &#39;MEL quantile&#39;) lines(qas,c1,type=&#39;l&#39;,lty=1,lwd=1.5,col=&#39;blue1&#39;) lines(qas,c2,type=&#39;l&#39;,lty=3,lwd=1.5,col=&#39;aquamarine4&#39;) lines(qas,c3,type=&#39;l&#39;,lty=5,lwd=1.5,col=&#39;brown2&#39;) points(qnorm(0.95),qnorm(0.95),pch=5) # 绘制卡方QQ图 x &lt;- seq(0,120,5) # 卡方的分位数点 c1 = sort(EL[,1])[ceiling(as*nsim)] # mel的分位数点 c2 = sort(EL[,2])[ceiling(as*nsim)] c3 = sort(EL[,3])[ceiling(as*nsim)] plot(x,x,xaxs = &#39;i&#39;, yaxs = &#39;i&#39;, xlim =c(min(qchisq(as,ps[1])), max(qchisq(as,ps[3]))), ylim =c(min(qchisq(as,ps[1])), max(qchisq(as,ps[3]))), yaxt = &#39;n&#39;, ann = F, type = &#39;l&#39;) axis(2, las = 1) title(main = paste0(&#39;ChiS n = &#39;,n,&#39; index = &#39;,index), xlab = &#39;ChiSquare quantile&#39;, ylab = &#39;EL quantile&#39;) lines(qchisq(as,ps[1]),c1,type=&#39;l&#39;,lty=1,lwd=1.5,col=&#39;blue1&#39;) lines(qchisq(as,ps[2]),c2,type=&#39;l&#39;,lty=3,lwd=1.5,col=&#39;aquamarine4&#39;) lines(qchisq(as,ps[3]),c3,type=&#39;l&#39;,lty=5,lwd=1.5,col=&#39;brown2&#39;) points(qchisq(0.95,ps[1]),qchisq(0.95,ps[1]),pch=5,col=&#39;blue1&#39;) points(qchisq(0.95,ps[2]),qchisq(0.95,ps[2]),pch=5,col=&#39;aquamarine4&#39;) points(qchisq(0.95,ps[3]),qchisq(0.95,ps[3]),pch=5,col=&#39;brown2&#39;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
